// (c) Meta Platforms, Inc. and affiliates. Confidential and proprietary.

#include <gtest/gtest.h>

#include <folly/FileUtil.h>
#include <folly/testing/TestUtil.h>

#include "fboss/platform/weutil/FbossEepromInterface.h"
#include "fboss/platform/weutil/if/gen-cpp2/eeprom_contents_types.h"

namespace facebook::fboss::platform {

namespace {
using EepromData = std::vector<uint8_t>;

// Based on the Spec for V5 EEPROM:
// https://github.com/facebook/fboss/blob/main/fboss/docs/meta_eeprom_format_v5.md
EepromData kEepromV5 = {
    0xfb, 0xfb, 0x05, 0xff, 0x01, 0x0d, 0x46, 0x49, 0x52, 0x53, 0x54, 0x5f,
    0x53, 0x51, 0x55, 0x45, 0x45, 0x5a, 0x45, 0x02, 0x08, 0x32, 0x30, 0x31,
    0x32, 0x33, 0x34, 0x35, 0x36, 0x03, 0x08, 0x53, 0x59, 0x53, 0x41, 0x31,
    0x32, 0x33, 0x34, 0x04, 0x0c, 0x50, 0x43, 0x42, 0x41, 0x31, 0x32, 0x33,
    0x34, 0x35, 0x36, 0x37, 0x20, 0x05, 0x0c, 0x50, 0x43, 0x42, 0x31, 0x32,
    0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x20, 0x06, 0x0c, 0x4d, 0x59, 0x4f,
    0x44, 0x4d, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x07, 0x0d, 0x4f,
    0x53, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x41, 0x42,
    0x08, 0x01, 0x01, 0x09, 0x01, 0x00, 0x0a, 0x01, 0x01, 0x0b, 0x0d, 0x50,
    0x53, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x41,
    0x0c, 0x07, 0x55, 0x4e, 0x41, 0x5f, 0x4d, 0x41, 0x53, 0x0d, 0x08, 0x32,
    0x30, 0x31, 0x33, 0x30, 0x32, 0x30, 0x33, 0x0e, 0x05, 0x54, 0x45, 0x52,
    0x5a, 0x4f, 0x0f, 0x09, 0x4a, 0x55, 0x49, 0x43, 0x45, 0x54, 0x4f, 0x52,
    0x59, 0x10, 0x07, 0x42, 0x55, 0x44, 0x4f, 0x4b, 0x41, 0x4e, 0x11, 0x08,
    0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x01, 0x02, 0x12, 0x08, 0x12, 0x34,
    0x56, 0x78, 0x9a, 0xbc, 0x03, 0x04, 0x13, 0x08, 0x66, 0x55, 0x44, 0x33,
    0x22, 0x11, 0x02, 0x00, 0x14, 0x08, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54,
    0x00, 0x02, 0xfa, 0x02, 0xd5, 0xc6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

// EEPROM V5 with wrong CRC Programmed (same as the one above, but last 2
// bytes have wrong CRC value programmed.)
EepromData kEepromV5WrongCrc = {
    0xfb, 0xfb, 0x05, 0xff, 0x01, 0x0d, 0x46, 0x49, 0x52, 0x53, 0x54, 0x5f,
    0x53, 0x51, 0x55, 0x45, 0x45, 0x5a, 0x45, 0x02, 0x08, 0x32, 0x30, 0x31,
    0x32, 0x33, 0x34, 0x35, 0x36, 0x03, 0x08, 0x53, 0x59, 0x53, 0x41, 0x31,
    0x32, 0x33, 0x34, 0x04, 0x0c, 0x50, 0x43, 0x42, 0x41, 0x31, 0x32, 0x33,
    0x34, 0x35, 0x36, 0x37, 0x20, 0x05, 0x0c, 0x50, 0x43, 0x42, 0x31, 0x32,
    0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x20, 0x06, 0x0c, 0x4d, 0x59, 0x4f,
    0x44, 0x4d, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x07, 0x0d, 0x4f,
    0x53, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x41, 0x42,
    0x08, 0x01, 0x01, 0x09, 0x01, 0x00, 0x0a, 0x01, 0x01, 0x0b, 0x0d, 0x50,
    0x53, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x41,
    0x0c, 0x07, 0x55, 0x4e, 0x41, 0x5f, 0x4d, 0x41, 0x53, 0x0d, 0x08, 0x32,
    0x30, 0x31, 0x33, 0x30, 0x32, 0x30, 0x33, 0x0e, 0x05, 0x54, 0x45, 0x52,
    0x5a, 0x4f, 0x0f, 0x09, 0x4a, 0x55, 0x49, 0x43, 0x45, 0x54, 0x4f, 0x52,
    0x59, 0x10, 0x07, 0x42, 0x55, 0x44, 0x4f, 0x4b, 0x41, 0x4e, 0x11, 0x08,
    0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x01, 0x02, 0x12, 0x08, 0x12, 0x34,
    0x56, 0x78, 0x9a, 0xbc, 0x03, 0x04, 0x13, 0x08, 0x66, 0x55, 0x44, 0x33,
    0x22, 0x11, 0x02, 0x00, 0x14, 0x08, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54,
    0x00, 0x02, 0xfa, 0x02, 0xa6, 0xb7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

// Based on the Spec for V6 EEPROM:
// https://github.com/facebook/fboss/blob/main/fboss/docs/meta_eeprom_format_v6.md
EepromData kEepromV6 = {
    0xfb, 0xfb, 0x06, 0xff, 0x01, 0x0d, 0x46, 0x49, 0x52, 0x53, 0x54, 0x5f,
    0x53, 0x51, 0x55, 0x45, 0x45, 0x5a, 0x45, 0x02, 0x08, 0x32, 0x30, 0x31,
    0x32, 0x33, 0x34, 0x35, 0x36, 0x03, 0x08, 0x53, 0x59, 0x53, 0x41, 0x31,
    0x32, 0x33, 0x34, 0x04, 0x0c, 0x50, 0x43, 0x42, 0x41, 0x31, 0x32, 0x33,
    0x34, 0x35, 0x36, 0x37, 0x20, 0x05, 0x0c, 0x50, 0x43, 0x42, 0x31, 0x32,
    0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x20, 0x06, 0x0c, 0x4d, 0x59, 0x4f,
    0x44, 0x4d, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x07, 0x0d, 0x4f,
    0x53, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x41, 0x42,
    0x08, 0x01, 0x01, 0x09, 0x01, 0x00, 0x0a, 0x01, 0x01, 0x0b, 0x0d, 0x50,
    0x53, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x41,
    0x0c, 0x07, 0x55, 0x4e, 0x41, 0x5f, 0x4d, 0x41, 0x53, 0x0d, 0x08, 0x32,
    0x30, 0x31, 0x33, 0x30, 0x32, 0x30, 0x33, 0x0e, 0x05, 0x54, 0x45, 0x52,
    0x5a, 0x4f, 0x0f, 0x09, 0x4a, 0x55, 0x49, 0x43, 0x45, 0x54, 0x4f, 0x52,
    0x59, 0x10, 0x07, 0x42, 0x55, 0x44, 0x4f, 0x4b, 0x41, 0x4e, 0x11, 0x08,
    0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x01, 0x02, 0x12, 0x08, 0x12, 0x34,
    0x56, 0x78, 0x9a, 0xbc, 0x03, 0x04, 0x13, 0x08, 0x66, 0x55, 0x44, 0x33,
    0x22, 0x11, 0x02, 0x00, 0x14, 0x08, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54,
    0x00, 0x02, 0x15, 0x01, 0x01, 0x65, 0x05, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x66, 0x05, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0xfa, 0x02, 0x4a, 0x05, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff};

// ONIE TlvInfo format test data
// clang-format off
EepromData eepromOnie = {
    // Header: "TlvInfo\x00" + version(0x01) + total_length(0x0050 = 80 bytes)
    0x54, 0x6c, 0x76, 0x49, 0x6e, 0x66, 0x6f, 0x00, 0x01, 0x00, 0x50,
    // Product Name TLV (0x21, length=11, "TestProduct")
    0x21, 0x0b,
    0x54, 0x65, 0x73, 0x74, 0x50, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x74,
    // Part Number TLV (0x22, length=7, "PN12345")
    0x22, 0x07, 0x50, 0x4e, 0x31, 0x32, 0x33, 0x34, 0x35,
    // Serial Number TLV (0x23, length=9, "SN1234567")
    0x23, 0x09, 0x53, 0x4e, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
    // Base MAC Address TLV (0x24, length=6, 00:11:22:33:44:55)
    0x24, 0x06, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55,
    // MAC Addresses TLV (0x2A, length=2, 256 addresses)
    0x2a, 0x02, 0x01, 0x00,
    // Manufacturer TLV (0x2B, length=7, "TestMfg")
    0x2b, 0x07, 0x54, 0x65, 0x73, 0x74, 0x4d, 0x66, 0x67,
    // CRC-32 TLV (0xFE, length=4, placeholder CRC)
    0xfe, 0x04, 0x12, 0x34, 0x56, 0x78
};

// Real device ONIE EEPROM data from Nexthop NH-4010
EepromData eepromOnieReal = {
    // Header: "TlvInfo\x00" + version(0x01) + total_length(0x0076 = 118 bytes)
    0x54, 0x6c, 0x76, 0x49, 0x6e, 0x66, 0x6f, 0x00, 0x01, 0x00, 0x76,
    // Product Name TLV (0x21, length=7, "NH-4010")
    0x21, 0x07, 0x4e, 0x48, 0x2d, 0x34, 0x30, 0x31, 0x30,
    // Part Number TLV (0x22, length=12, "950-00001-01")
    0x22, 0x0c,
    0x39, 0x35, 0x30, 0x2d, 0x30, 0x30, 0x30, 0x30, 0x31, 0x2d, 0x30, 0x31,
    // Serial Number TLV (0x23, length=14, "NH-FSJ25160005")
    0x23, 0x0e,
    0x4e, 0x48, 0x2d, 0x46, 0x53, 0x4a, 0x32,
    0x35, 0x31, 0x36, 0x30, 0x30, 0x30, 0x35,
    // Base MAC Address TLV (0x24, length=6, E8:E4:9D:00:18:28)
    0x24, 0x06, 0xe8, 0xe4, 0x9d, 0x00, 0x18, 0x28,
    // Device Version TLV (0x26, length=1, 1)
    0x26, 0x01, 0x01,
    // Label Revision TLV (0x27, length=2, "P1")
    0x27, 0x02, 0x50, 0x31,
    // Platform Name TLV (0x28, length=22, "x86_64-nexthop_4010-r0")
    0x28, 0x16, 0x78, 0x38, 0x36, 0x5f, 0x36, 0x34, 0x2d, 0x6e, 0x65, 0x78,
    0x74, 0x68, 0x6f, 0x70, 0x5f, 0x34, 0x30, 0x31, 0x30, 0x2d, 0x72, 0x30,
    // Manufacturer TLV (0x2B, length=7, "Nexthop")
    0x2b, 0x07, 0x4e, 0x65, 0x78, 0x74, 0x68, 0x6f, 0x70,
    // Vendor TLV (0x2D, length=7, "Nexthop")
    0x2d, 0x07, 0x4e, 0x65, 0x78, 0x74, 0x68, 0x6f, 0x70,
    // Service Tag TLV (0x2F, length=14, "www.nexthop.ai")
    0x2f, 0x0e, 0x77, 0x77, 0x77, 0x2e, 0x6e, 0x65,
    0x78, 0x74, 0x68, 0x6f, 0x70, 0x2e, 0x61, 0x69,
    // CRC-32 TLV (0xFE, length=4, 0xB06FDC7B)
    0xfe, 0x04, 0xb0, 0x6f, 0xdc, 0x7b,
};
// clang-format on

FbossEepromInterface createFbossEepromInterface(const EepromData& data) {
  folly::test::TemporaryDirectory tmpDir = folly::test::TemporaryDirectory();
  std::string fileName = tmpDir.path().string() + "/eepromContent";
  folly::writeFile(data, fileName.c_str());

  return FbossEepromInterface(fileName, 0);
}

constexpr auto kProductName = "FIRST_SQUEEZE";
constexpr auto kProductPartNumber = "20123456";
constexpr auto kSystemAssemblyPartNumber = "SYSA1234";
constexpr auto kMetaPCBAPartNumber = "PCBA1234567";
constexpr auto kMetaPCBPartNumber = "PCB12345678";
constexpr auto kOdmJdmPCBAPartNumber = "MYODM1234567";
constexpr auto kOdmJdmPCBASerialNumber = "OS123456789AB";
constexpr auto kProductionState = "1";
constexpr auto kProductionSubState = "0";
constexpr auto kVariantIndicator = "1";
constexpr auto kProductSerialNumber = "PS1234567890A";
constexpr auto kSystemManufacturer = "UNA_MAS";
constexpr auto kSystemManufacturingDate = "20130203";
constexpr auto kPCBManufacturer = "TERZO";
constexpr auto kAssembledAt = "JUICETORY";
constexpr auto kEepromLocationOnFabric = "BUDOKAN";
constexpr auto kX86CpuMac = "11:22:33:44:55:66,258";
constexpr auto kBmcMac = "12:34:56:78:9a:bc,772";
constexpr auto kSwitchAsicMac = "66:55:44:33:22:11,512";
constexpr auto kMetaReservedMac = "fe:dc:ba:98:76:54,2";
constexpr auto kRma = "1";
constexpr auto kVendorDefinedField1 = "0x0101010101";
constexpr auto kVendorDefinedField2 = "0x48656c6c6f";
constexpr auto kVendorDefinedField3 = "";
constexpr auto kCrc16V5 = "0xd5c6";
constexpr auto kCrc16V6 = "0x4a05";
constexpr auto kCrcCorrectTemplate = "{} (CRC Matched)";
constexpr auto kCrc16WrongTemplate = "0xa6b7 (CRC Mismatch. Expected {})";

EepromContents createEepromContents(int version, bool crcMatched = true) {
  EepromContents result;
  result.version() = version;
  result.productName() = kProductName;
  result.productPartNumber() = kProductPartNumber;
  result.systemAssemblyPartNumber() = kSystemAssemblyPartNumber;
  result.metaPCBAPartNumber() = kMetaPCBAPartNumber;
  result.metaPCBPartNumber() = kMetaPCBPartNumber;
  result.odmJdmPCBAPartNumber() = kOdmJdmPCBAPartNumber;
  result.odmJdmPCBASerialNumber() = kOdmJdmPCBASerialNumber;
  result.productionState() = kProductionState;
  result.productionSubState() = kProductionSubState;
  result.variantIndicator() = kVariantIndicator;
  result.productSerialNumber() = kProductSerialNumber;
  result.systemManufacturer() = kSystemManufacturer;
  result.systemManufacturingDate() = kSystemManufacturingDate;
  result.pcbManufacturer() = kPCBManufacturer;
  result.assembledAt() = kAssembledAt;
  result.eepromLocationOnFabric() = kEepromLocationOnFabric;
  result.x86CpuMac() = kX86CpuMac;
  result.bmcMac() = kBmcMac;
  result.switchAsicMac() = kSwitchAsicMac;
  result.metaReservedMac() = kMetaReservedMac;
  const std::string crc16 = version == 5 ? kCrc16V5 : kCrc16V6;

  if (crcMatched) {
    result.crc16() = fmt::format(kCrcCorrectTemplate, crc16);
  } else {
    result.crc16() = fmt::format(kCrc16WrongTemplate, crc16);
  }

  // V6 unique fields
  if (version == 6) {
    result.rma() = kRma;
    result.vendorDefinedField1() = kVendorDefinedField1;
    result.vendorDefinedField2() = kVendorDefinedField2;
    result.vendorDefinedField3() = kVendorDefinedField3;
  }

  return result;
};

} // namespace

TEST(FbossEepromInterfaceTest, V5) {
  auto eeprom = createFbossEepromInterface(kEepromV5);

  EXPECT_EQ(eeprom.getProductName(), kProductName);
  EXPECT_EQ(eeprom.getProductPartNumber(), kProductPartNumber);
  EXPECT_EQ(eeprom.getProductionState(), kProductionState);
  EXPECT_EQ(eeprom.getProductionSubState(), kProductionSubState);
  EXPECT_EQ(eeprom.getVariantVersion(), kVariantIndicator);
  EXPECT_EQ(eeprom.getProductSerialNumber(), kProductSerialNumber);
}

TEST(FbossEepromInterfaceTest, V5WrongCRC) {
  auto eeprom = createFbossEepromInterface(kEepromV5WrongCrc);
  EXPECT_EQ(eeprom.getProductName(), kProductName);
  EXPECT_EQ(eeprom.getProductPartNumber(), kProductPartNumber);
  EXPECT_EQ(eeprom.getProductionState(), kProductionState);
  EXPECT_EQ(eeprom.getProductionSubState(), kProductionSubState);
  EXPECT_EQ(eeprom.getVariantVersion(), kVariantIndicator);
  EXPECT_EQ(eeprom.getProductSerialNumber(), kProductSerialNumber);
}

TEST(FbossEepromInterfaceTest, V6) {
  auto eeprom = createFbossEepromInterface(kEepromV6);
  EXPECT_EQ(eeprom.getProductName(), kProductName);
  EXPECT_EQ(eeprom.getProductPartNumber(), kProductPartNumber);
  EXPECT_EQ(eeprom.getProductionState(), kProductionState);
  EXPECT_EQ(eeprom.getProductionSubState(), kProductionSubState);
  EXPECT_EQ(eeprom.getVariantVersion(), kVariantIndicator);
  EXPECT_EQ(eeprom.getProductSerialNumber(), kProductSerialNumber);
}

TEST(FbossEepromInterfaceTest, V5Object) {
  auto eepromInterace = createFbossEepromInterface(kEepromV5);
  auto actualObj = eepromInterace.getEepromContents();

  EepromContents expectedObj = createEepromContents(5);

  EXPECT_EQ(actualObj, expectedObj);
}

TEST(FbossEepromInterfaceTest, V6Object) {
  auto eepromInterace = createFbossEepromInterface(kEepromV6);
  auto actualObj = eepromInterace.getEepromContents();
  EepromContents expectedObj = createEepromContents(6);

  EXPECT_EQ(actualObj, expectedObj);
}

TEST(FbossEepromInterfaceTest, V5ObjWrongCrc) {
  auto eeprom = createFbossEepromInterface(kEepromV5WrongCrc);
  auto actualObj = eeprom.getEepromContents();
  EepromContents expectedObj = createEepromContents(5, false);

  EXPECT_EQ(actualObj, expectedObj);
}

TEST(FbossEepromOnieTest, OnieFormat) {
  std::vector<std::pair<std::string, std::string>> expectedContentsDummy = {
      {"Format", "ONIE TlvInfo"},
      {"Product Name", "TestProduct"},
      {"Part Number", "PN12345"},
      {"Serial Number", "SN1234567"},
      {"Base MAC Address", "00:11:22:33:44:55"},
      {"Manufacture Date", ""},
      {"Device Version", ""},
      {"Label Revision", ""},
      {"Platform Name", ""},
      {"ONIE Version", ""},
      {"MAC Addresses", "256"},
      {"Manufacturer", "TestMfg"},
      {"Manufacture Country", ""},
      {"Vendor Name", ""},
      {"Diag Version", ""},
      {"Service Tag", ""},
      {"Vendor Extension", ""},
      {"CRC-32", "0x12345678 (CRC Mismatch. Expected 0x7e83c97f)"},
  };
  std::vector<std::pair<std::string, std::string>> expectedContentsNH4010 = {
      {"Format", "ONIE TlvInfo"},
      {"Product Name", "NH-4010"},
      {"Part Number", "950-00001-01"},
      {"Serial Number", "NH-FSJ25160005"},
      {"Base MAC Address", "e8:e4:9d:00:18:28"},
      {"Manufacture Date", ""},
      {"Device Version", "1"},
      {"Label Revision", "P1"},
      {"Platform Name", "x86_64-nexthop_4010-r0"},
      {"ONIE Version", ""},
      {"MAC Addresses", ""},
      {"Manufacturer", "Nexthop"},
      {"Manufacture Country", ""},
      {"Vendor Name", "Nexthop"},
      {"Diag Version", ""},
      {"Service Tag", "www.nexthop.ai"},
      {"Vendor Extension", ""},
      {"CRC-32", "0xb06fdc7b (CRC Matched)"},
  };

  std::vector<
      std::pair<EepromData, std::vector<std::pair<std::string, std::string>>>>
      testCases = {
          {eepromOnie, expectedContentsDummy},
          {eepromOnieReal, expectedContentsNH4010},
      };

  for (auto& [eepromData, expectedContents] : testCases) {
    folly::test::TemporaryDirectory tmpDir = folly::test::TemporaryDirectory();
    std::string fileName = tmpDir.path().string() + "/eepromContent";
    folly::writeFile(eepromData, fileName.c_str());
    FbossEepromInterface interface(fileName, 0);
    auto parsedContents = interface.getContents();
    ASSERT_EQ(expectedContents.size(), parsedContents.size());
    for (size_t i = 0; i < expectedContents.size(); i++) {
      EXPECT_EQ(parsedContents[i], expectedContents[i]);
    }
  }
}

} // namespace facebook::fboss::platform
