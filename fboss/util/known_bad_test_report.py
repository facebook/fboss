#!/usr/bin/env python3

# Copyright 2004-present Facebook. All Rights Reserved.

# pyre-unsafe

import argparse
import getpass
import json
import logging
import os
import sys
import time
import typing as t
from datetime import date
from typing import Any, Dict, Optional

import libfb.py.asyncio.tasks as task_api

from analytics.bamboo import Bamboo as bb
from libfb.py import employee
from libfb.py.asyncio.await_utils import asyncio
from libfb.py.asyncio.tasks import Task, TaskPriority
from libfb.py.mail import async_send_internal_email
from libfb.py.thrift_clients.oncall_thrift_client import OncallThriftClient


# Configure logging
logger: logging.Logger = logging.getLogger(__name__)
logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)

# Constants
DEFAULT_MAX_RECORDS = "100"  # Default number of records returned from scuba
DEFAULT_OUTPUT_FILE = "known_bad_tests_data.json"
ONCALL = "fboss_agent_push"
PASSED = 1
FAILED = 0
USER_UNIX_ID = "prasoon"
KNOWN_BAD_TEST = "known_bad_tests"
FBOSS_KNOWN_BAD_TESTS = f"fboss_{KNOWN_BAD_TEST}"


class UserAndEmailHandler:
    @staticmethod
    def get_oncall_info(oncall_name: str) -> Any:
        """
        Retrieve the user ID of the current on-call person for a given rotation by short name.

        Args:
            oncall_name (str): The short name of the on-call rotation.

        Returns:
            int: The user ID of the current on-call person.
        """
        with OncallThriftClient() as client:
            oncall = client.getCurrentOncallForRotationByShortName(oncall_name)
            logger.info(f"Current on-call for {oncall}: {oncall.uid}")
            return oncall

    def _get_user_data(self, isUser: bool) -> t.Tuple[str, int, str]:
        """
        Get the current user's name and ID, falling back to on-call information if needed.

        Returns:
            tuple: A tuple containing:
                - str: The username (either the current user or the on-call name)
                - int: The user ID corresponding to the username
                - str: The email of the on-call person
        """
        if isUser:
            user_name = os.environ.get("SUDO_USER", getpass.getuser())
            user_id = employee.unixname_to_uid(user_name)
            return user_name, user_id, ""
        else:
            oncall = UserAndEmailHandler.get_oncall_info(ONCALL)
            user_name = ONCALL
            logger.info(f"User name: {user_name}, User ID: {oncall.uid}")
            return user_name, oncall.uid, oncall.person_email

    async def send_email(
        self, isUser: bool, html: str, images: Optional[Dict[str, bytes]]
    ) -> None:
        """
        Send an email with the given HTML content and images.

        Args:
            html (str): The HTML content of the email.
            images (Dict[str, bytes]): A dictionary of image names and their byte content to be included in the email.
        """
        subject = "Known bad tests report. Date: %s" % date.today().strftime("%Y-%m-%d")

        user_name, _user_id, user_email = self._get_user_data(isUser)

        if user_email:
            to_addrs = [user_email]
        else:
            to_addrs = [("%s@meta.com" % user_name)]

        logger.info(f"Sending email to {to_addrs}")
        await async_send_internal_email(
            sender="noreply@meta.com",
            to=to_addrs,
            subject=subject,
            body=html,
            inline_images=images,
            is_html=True,
        )

    async def create_task(self, isUser: bool, tests: Dict[str, int]) -> Task:
        owner, _user_id, _user_email = self._get_user_data(isUser)

        return await task_api.create_task(
            creator=USER_UNIX_ID,
            title="Known Bad Tests Passing Continuously for a week. Please remove them from known bad.",
            description=self.text_format_known_bad_list(tests),
            priority=TaskPriority.HIGH,
            tags=[FBOSS_KNOWN_BAD_TESTS],
            owner=owner,
        )

    def HTTP_format_known_bad_list(self, tests: Dict[str, int]) -> str:
        """Format the test data into a Workplace post."""
        html = "<h1>Known bad tests passing continuously for a week</h1>"
        html += "<p>Here is the list of known bad tests passing 7 times in a row:</p>"
        html += "<p>Please remove them from known bad. </p>"
        html += "<table>"
        html += "<tr><th>Test Name</th></tr>"
        for test_name, _status in tests.items():
            html += f"<tr><td>{test_name}</td></tr>"
        html += "</table>"
        return html

    def text_format_known_bad_list(self, tests: Dict[str, int]) -> str:
        """Format the test data into a Workplace post."""
        text = "Known bad tests passing continuously for a week\n"
        text += "Here is the list of known bad tests passing 7 times in a row:\n"
        text += "Please remove them from known bad.\n"
        text += "Test Name\n"
        for test_name, _status in tests.items():
            text += f"{test_name}\n"
        return text


class ScubaQueryBuilder:
    """Class to build and execute Scuba queries for Chronos jobs."""

    @staticmethod
    def build_query_for_test_results(
        limit: str = DEFAULT_MAX_RECORDS,
    ) -> str:
        """Build a Scuba query for Chronos jobs."""
        current_time = int(time.time())
        consider_results_since = str(current_time - 60 * 60 * 24 * 7)  # Last 7 days

        sql_query = f"""
            SELECT
                SUM(1, `weight`) AS `count`,
                COUNT(1) AS `samples`,
                `test_name`,
                `status`
            FROM `testinfra_db_results`
            WHERE
                {consider_results_since} <= `time`
                AND `time` <= {current_time}
                AND (CONTAINS(`sandcastle_alias`, ARRAY('sai_agent_known_bad_test')))
                AND ((`purpose`) IN ('stress-run'))
                AND (`status`) IN (1)
            GROUP BY
                `test_name`,
                `status`
            ORDER BY
                `count` DESC
            LIMIT
                {limit}
            """

        return sql_query

    @staticmethod
    def execute_query(sql_query: str) -> Optional[Any]:
        """Execute a Scuba query and return the results."""
        try:
            df = bb.query_scuba_nullable(sql_query)
            return df
        except Exception as e:
            logger.error(f"Error querying Scuba: {e}")
            return None


def main() -> Optional[int]:
    """Main function to parse command line arguments and run the script."""
    parser = argparse.ArgumentParser(
        description="Get data from a Scuba for sai_agent_known_bad_test"
    )

    parser.add_argument(
        "--query_scuba",
        action="store_true",
        help="Query Scuba for test results",
    )

    parser.add_argument(
        "--debug",
        action="store_true",
        help="Print debug messages",
    )

    parser.add_argument(
        "--user",
        action="store_true",
        help="Send email to user instead of oncall",
    )

    args = parser.parse_args()

    if args.query_scuba:
        # Query Scuba for test result
        logger.info("Querying Scuba for test results...")
        sql_query = ScubaQueryBuilder.build_query_for_test_results()
        df = ScubaQueryBuilder.execute_query(sql_query)

        if df is None:
            logger.error("Error: Could not execute Scuba query")
            return 1
        logger.info(f"Scuba query returned {len(df)} rows")
        tests = {}

        for _, row in df.iterrows():
            if row["status"] == PASSED and row["count"] == 7:
                if row["test_name"] not in tests:
                    tests[row["test_name"]] = row["status"]

        logger.info(f"Found {len(tests)} known bad tests passing 7 times in a row")

        # Write test data to a separate JSON file
        if tests:
            with open(DEFAULT_OUTPUT_FILE, "w") as f:
                json.dump(tests, f, indent=2, default=str)
            logger.info(f"Results written to {DEFAULT_OUTPUT_FILE}")

            # send email to user or oncall
            logger.info("Sending email...")
            html = UserAndEmailHandler().HTTP_format_known_bad_list(tests)

            logger.info("html generated successfully for email body")
            images = {}
            return_code = asyncio.run(
                UserAndEmailHandler().send_email(args.user, html, images)
            )

            if return_code == 0:
                logger.error(
                    f"Error: Failed to send email to user, return_code: {return_code}"
                )
                return return_code

            logger.info(f"Email sent successfully return_code: {return_code}")

            # create task for user or oncall
            logger.info("Creating task for oncall...")
            task = asyncio.run(UserAndEmailHandler().create_task(args.user, tests))
            logger.info(f"Task created successfully: {task.task_number}")
        else:
            logger.info("No known bad tests found")

    return 0


# No code to edit in the selected snippet.

if __name__ == "__main__":
    sys.exit(main())
